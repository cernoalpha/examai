'use strict';

var axios = require('axios');
var EventEmitter = require('events');
var fs = require('fs');
var FormData = require('form-data');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var axios__default = /*#__PURE__*/_interopDefault(axios);
var EventEmitter__default = /*#__PURE__*/_interopDefault(EventEmitter);
var FormData__default = /*#__PURE__*/_interopDefault(FormData);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __asyncGenerator = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  };
  var method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no));
  var it = {};
  return generator = generator.apply(__this, __arguments), it[Symbol.asyncIterator] = () => it, method("next"), method("throw"), method("return"), it;
};

// src/components/index.ts
var APIModule = class {
  constructor(client) {
    this.client = client;
  }
};

// src/utils/index.ts
function parseEventString(evt) {
  const eventRegex = /event:\s*(.+)/;
  const dataRegex = /data:\s*(.+)/;
  const traceIdRegex = /trace_id:\s*(.+)/;
  const documentChunksRegex = /document_chunks:\s*(.+)/;
  const eventMatch = evt.match(eventRegex);
  const dataMatch = evt.match(dataRegex);
  const traceIdMatch = evt.match(traceIdRegex);
  const documentChunksMatch = evt.match(documentChunksRegex);
  const event = eventMatch ? eventMatch[1].trim() : null;
  let data = dataMatch ? dataMatch[1].trim() : null;
  const traceId = traceIdMatch ? traceIdMatch[1].trim() : null;
  const documentChunks = documentChunksMatch ? JSON.parse(documentChunksMatch[1].trim()) : null;
  if (data) {
    if (data === "[DONE]") {
      data = { traceId, documentChunks };
    } else {
      data = JSON.parse(data);
    }
  }
  return { event, data };
}
function eventEmitterToAsyncIterable(eventEmitter) {
  const queue = [];
  let resolveQueue = [];
  function enqueue(value) {
    if (resolveQueue.length > 0) {
      const resolve = resolveQueue.shift();
      resolve({ value, done: false });
    } else {
      queue.push(value);
    }
  }
  function end() {
    for (const resolve of resolveQueue) {
      resolve({ value: void 0, done: true });
    }
    resolveQueue = [];
  }
  const out = {
    trace_id: null,
    document_chunks: null,
    [Symbol.asyncIterator]() {
      return __asyncGenerator(this, null, function* () {
        while (true) {
          if (queue.length > 0) {
            const value = queue.shift();
            yield value;
          } else {
            const promise = new Promise((resolve) => resolveQueue.push(resolve));
            const result = yield new __await(promise);
            if (result.done)
              return;
            yield result.value;
          }
        }
      });
    }
  };
  eventEmitter.on("data", enqueue);
  eventEmitter.once("end", end);
  eventEmitter.once("trace", (traceId) => {
    out.trace_id = traceId;
  });
  eventEmitter.once("document_chunks", (documentChunks) => {
    out.document_chunks = documentChunks;
  });
  return out;
}

// src/modules/chat.completions/operations/v1_chat_completions_create.ts
var v1_chat_completions_create_default = (client) => (args, options) => __async(void 0, null, function* () {
  const baseOptions = __spreadValues({
    method: "POST",
    data: args,
    url: "/v1/chat/completions"
  }, options);
  if (args.stream) {
    const rawStream = yield client.call(__spreadProps(__spreadValues({}, baseOptions), {
      responseType: "stream"
    }));
    const parsedEventEmitter = new EventEmitter__default.default();
    let buffer = "";
    rawStream.on("data", (chunk) => {
      buffer += chunk.toString();
      let splitPattern = /\n\nevent:/g;
      let events = buffer.split(splitPattern);
      if (events.length > 1) {
        events.slice(0, -1).forEach((eventString) => {
          eventString = eventString.startsWith("event:") ? eventString : "event:" + eventString;
          const { data, event } = parseEventString(eventString);
          if (event === "completion" && data !== null) {
            parsedEventEmitter.emit("data", data);
          } else if (event === "done") {
            parsedEventEmitter.emit("trace", data.traceId);
            parsedEventEmitter.emit("document_chunks", data.documentChunks);
            parsedEventEmitter.emit("end");
          }
        });
        buffer = events[events.length - 1];
      }
    });
    rawStream.on("end", () => {
      if (buffer.trim()) {
        if (!buffer.startsWith("event:")) {
          buffer = "event:" + buffer;
        }
        const { data, event } = parseEventString(buffer);
        if (event === "completion" && data !== null) {
          parsedEventEmitter.emit("data", data);
        } else if (event === "done") {
          parsedEventEmitter.emit("trace", data.traceId);
          parsedEventEmitter.emit("document_chunks", data.documentChunks);
          parsedEventEmitter.emit("end");
        }
      }
    });
    const iterable = eventEmitterToAsyncIterable(parsedEventEmitter);
    return iterable;
  } else {
    return client.call(baseOptions);
  }
});

// src/modules/chat.completions/index.ts
var chat_default = class extends APIModule {
  constructor() {
    super(...arguments);
    this.create = v1_chat_completions_create_default(this.client);
  }
};

// src/modules/embeddings/operations/v1_embeddings_create.ts
var v1_embeddings_create_default = (client) => (params, options) => {
  return client.call(__spreadValues({
    method: "post",
    url: `/v1/embeddings`,
    data: params
  }, options));
};

// src/modules/embeddings/index.ts
var embeddings_default = class extends APIModule {
  constructor() {
    super(...arguments);
    this.create = v1_embeddings_create_default(this.client);
  }
};

// src/modules/models/operations/v1_models_list.ts
var v1_models_list_default = (client) => (options) => {
  return client.call(__spreadValues({
    method: "get",
    url: `/v1/models/`
  }, options));
};

// src/modules/models/operations/v1_models_retrieve.ts
var v1_models_retrieve_default = (client) => (id, options) => {
  return client.call(__spreadValues({
    method: "get",
    url: `/v1/models/${id}/`
  }, options));
};

// src/modules/models/index.ts
var models_default = class extends APIModule {
  constructor() {
    super(...arguments);
    this.list = v1_models_list_default(this.client);
    this.retrieve = v1_models_retrieve_default(this.client);
  }
};

// src/modules/repositories/operations/v1_repositories_create.ts
var v1_repositories_create_default = (client) => (params, options) => {
  return client.call(__spreadValues({
    method: "post",
    url: `/v1/repositories/`,
    data: params
  }, options));
};

// src/modules/repositories/index.ts
var repositories_default = class extends APIModule {
  constructor() {
    super(...arguments);
    this.create = v1_repositories_create_default(this.client);
  }
};
var v1_repository_document_create_default = (client) => (repository_id, params, options) => {
  const filePath = params.file;
  if (!fs.existsSync(filePath)) {
    throw new Error(`File not found: ${filePath}`);
  }
  const formData = new FormData__default.default();
  const fileStream = fs.createReadStream(filePath);
  formData.append("file", fileStream);
  return client.call(__spreadValues({
    method: "post",
    url: `/v1/repository/${repository_id}/document`,
    data: formData,
    headers: __spreadValues(__spreadValues({}, (options == null ? void 0 : options.headers) || {}), formData.getHeaders())
  }, options));
};

// src/modules/repository.document/index.ts
var repository_default = class extends APIModule {
  constructor() {
    super(...arguments);
    this.create = v1_repository_document_create_default(this.client);
  }
};

// src/modules/feedbacks/operations/v1_set_trace_feedback_create.ts
var v1_set_trace_feedback_create_default = (client) => (params, options) => {
  return client.call(__spreadValues({
    method: "post",
    url: `/v1/set_trace_feedback`,
    data: params
  }, options));
};

// src/modules/feedbacks/index.ts
var feedbacks_default = class extends APIModule {
  constructor() {
    super(...arguments);
    this.create = v1_set_trace_feedback_create_default(this.client);
  }
};

// src/modules/traces/operations/v1_traces_list.ts
var v1_traces_list_default = (client) => (options) => {
  return client.call(__spreadValues({
    method: "get",
    url: `/v1/traces/`
  }, options));
};

// src/modules/traces/operations/v1_traces_retrieve.ts
var v1_traces_retrieve_default = (client) => (id, options) => {
  return client.call(__spreadValues({
    method: "get",
    url: `/v1/traces/${id}/`
  }, options));
};

// src/modules/traces/index.ts
var traces_default = class extends APIModule {
  constructor() {
    super(...arguments);
    this.list = v1_traces_list_default(this.client);
    this.retrieve = v1_traces_retrieve_default(this.client);
  }
};

// src/index.ts
var Prem = class {
  constructor(config, axiosConfig) {
    this.chat = { completions: new chat_default(this) };
    this.embeddings = new embeddings_default(this);
    this.models = new models_default(this);
    this.repositories = new repositories_default(this);
    this.repository = { document: new repository_default(this) };
    this.feedbacks = new feedbacks_default(this);
    this.traces = new traces_default(this);
    this.call = (request) => __async(this, null, function* () {
      try {
        const { data } = yield this.axios.request(request);
        return data;
      } catch (e) {
        const error = e;
        const { response } = error;
        if (response == null ? void 0 : response.data) {
          throw response.data;
        }
        throw error;
      }
    });
    this.config = Object.assign({ baseUrl: "https://app.premai.io" }, config);
    this.axios = axios__default.default.create(axiosConfig);
    this.axios.defaults.baseURL = this.config.baseUrl;
    this.axios.defaults.headers.common["Authorization"] = `Bearer ${this.config.apiKey}`;
  }
};

module.exports = Prem;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map